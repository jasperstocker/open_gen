// This file isn't generated, but this comment is necessary to exclude it from StyleCop analysis.
// <auto-generated/>

using System.Collections.Generic;
using opengen.maths;
using UnityEngine;

namespace opengen.mesh
{
	public partial class DynamicMesh
	{
		protected static int LIST_SIZE = 65000;
		protected static int LIST_SIZE_TRI = 99000;

		protected string _name;
		public List<Vector3> vertices;
		public List<Vector2> uvs;
		public List<Vector3> normals;
		public List<int> triangles;
		public Bounds bounds;

		public List<Vector4> tangents;
		public List<Color32> colours;
		public bool ignoreSubmeshAssignment = false;
		protected int _subMeshes;
		public Dictionary<int, List<int>> subTriangles;

		protected DynamicMesh _overflow;

		public DynamicMesh(string newName)
		{
			_name = newName;
			vertices = new List<Vector3>(LIST_SIZE);
			uvs = new List<Vector2>(LIST_SIZE);
			triangles = new List<int>(LIST_SIZE_TRI);
			normals = new List<Vector3>(LIST_SIZE);
			tangents = new List<Vector4>(LIST_SIZE);
			colours = new List<Color32>(LIST_SIZE);
			subTriangles = new Dictionary<int, List<int>>();
			bounds = new Bounds();
		}

		public string name
		{
			get { return _name; }
			set { _name = value; }
		}

		public void Build(Mesh mesh)
		{
			if (mesh == null)
			{
				Debug.LogError("Mesh sent is null - where is this guy?");
				return;
			}
  
			mesh.Clear();
  
			if (vertices.Count == 0)
			{
				return;
			}

			mesh.SetVertices(vertices);
			mesh.SetUVs(0, uvs);
			mesh.SetNormals(normals);
			mesh.SetTangents(tangents);
			mesh.SetColors(colours);
			mesh.bounds = bounds;
			mesh.name = _name;
  
		    if(!ignoreSubmeshAssignment)
		    {
		        _subMeshes = 0;
                foreach (KeyValuePair<int, List<int>> triData in subTriangles)
                {
	                _subMeshes = Mathf.Max(_subMeshes, triData.Key);
                }

                _subMeshes += 1;
		        mesh.subMeshCount = _subMeshes;
                
		        for(int s = 0; s < _subMeshes; s++)
		        {
			        if(subTriangles.ContainsKey(s))
			        {
				        mesh.SetTriangles(subTriangles[s].ToArray(), s);
			        }
		        }
		    }
		    else
		    {
		        mesh.subMeshCount = 1;
                mesh.SetTriangles(subTriangles[0], 0);
		        _subMeshes = 1;
		    }
  
		    mesh.RecalculateBounds();//todo should we do this ourselves?
		}

		public DynamicMesh overflow { get { return _overflow; } }

		public bool hasOverflowed { get { return _overflow != null; } }

		/// <summary>
		/// Clears the mesh data, ready for nextNormIndex new mesh build
		/// </summary>
		public void Clear()
		{
			vertices.Clear();
			uvs.Clear();
			triangles.Clear();
			normals.Clear();
			tangents.Clear();
			colours.Clear();
			bounds.center = Vector3.zero;
			bounds.size = Vector3.zero;
			subTriangles.Clear();
			_subMeshes = 1;
			_overflow = null;
			ignoreSubmeshAssignment = false;
		}

		/// <summary>
		/// Clears the mesh data, ready for nextNormIndex new mesh build
		/// </summary>
		public void ClearMeshData()
		{
			vertices.Clear();
			uvs.Clear();
			triangles.Clear();
			normals.Clear();
			tangents.Clear();
			colours.Clear();
			bounds.center = Vector3.zero;
			bounds.size = Vector3.zero;
			subTriangles.Clear();
			_subMeshes = 0;
			_overflow = null;
		}

		public int vertexCount
		{
			get { return vertices.Count; }
		}

		public int triangleCount
		{
			get { return triangles.Count; }
		}

		public int subMeshCount
		{
			get { return _subMeshes; }
		}

		private Vector2 CalculateUv(Vector2 uv, TextureData textureData)
		{
			if (textureData != null)
			{
				if (textureData.tiled)
				{
					return textureData.CalculateUv(uv);
				}
			}

			return uv;
		}



        private Vector2 Rotate(Vector2 input, float degrees)
	    {
	        float sin = Mathf.Sin(degrees * Numbers.Deg2Rad);
	        float cos = Mathf.Cos(degrees * Numbers.Deg2Rad);

	        float tx = input.x;
	        float ty = input.y;
	        input.x = (cos * tx) - (sin * ty);
	        input.y = (sin * tx) + (cos * ty);
	        return input;
	    }


        /// <summary>
        /// Collapse all the submeshes into a single submesh
        /// </summary>
        public void CollapseSubmeshes()
		{
			List<int> singleSubmesh = new();
			int numberOfSubmeshesToModify = subTriangles.Count;
			for (int s = 0; s < numberOfSubmeshesToModify; s++)
			{
				if (subTriangles.ContainsKey(s))
				{
					int[] submeshIndices = subTriangles[s].ToArray();
					singleSubmesh.AddRange(submeshIndices);
				}
			}
			subTriangles.Clear();
			subTriangles.Add(0, singleSubmesh);
		}

		/// <summary>
		/// Check if the vertex count exceeds Unity's 65000 limit
		/// If it does, we create an overflow that continues the mesh construction
		/// If there is already an overflow, we've already exceeded the mesh count
		/// </summary>
		/// <param name="numberOfNewVerts">Number of verts being added to current total</param>
		/// <returns></returns>
		private bool MeshOverflow(int numberOfNewVerts)
		{
			if (_overflow != null)
			{
				return true;
			}

			if (numberOfNewVerts + vertexCount >= LIST_SIZE)
			{
				_overflow = new DynamicMesh(_name);
			    _overflow.ignoreSubmeshAssignment = ignoreSubmeshAssignment;

                return true;
			}
			return false;
		}

		public void ForceNewMesh()
		{
			if (_overflow != null)
			{
				_overflow.ForceNewMesh();
			}
			else
			{
				_overflow = new DynamicMesh(_name);
			}
		}
		
		/// <summary>
		/// Create a triangle index list from a given size
		/// Ideal used if you want to quickly triangulate a convex shape
		/// And you don't care too much about the triangle composition/quality
		/// You want it fast and cheap!
		/// </summary>
		/// <param name="size"></param>
		/// <returns></returns>
		public static int[] GenerateTriangleIndices(int size) {
			if (size < 3)
			{
				return null;
			}

			int faces = size - 2;
			int[] output = new int[faces * 3];
			for (int f = 0; f < faces; f++) {
				output[f * 3] = 0;
				output[f * 3 + 1] = f + 1;
				output[f * 3 + 2] = f + 2;
			}
			return output;
		}

		// /// <summary>
		// /// Calculate the normal of a triangle
		// /// </summary>
		// /// <param name="points">Only three points will be used in calculation</param>
		// public static Vector3 CalculateNormal(Vector3[] points)
		// {
		// 	if (points.Length < 3) return Vector3.down;//most likely to look wrong
		// 	return CalculateNormal(points[0], points[1], points[2]);
		// }
		//
		// /// <summary>
		// /// Calculate the normal of a triangle
		// /// </summary>
		// public static Vector3 CalculateNormal(Vector3 p0, Vector3 p1, Vector3 p2)
		// {
		// 	return Vector3.Cross((p1 - p0).normalized, (p2 - p0).normalized).normalized;
		// }
		//
		// private void VerticesAddRange(Vector3[] verts)
		// {
		// 	int vertCount = verts.Length;
		// 	for (int v = 0; v < vertCount; v++)
		// 		vertices.Add(verts[v]);
		// }
	}
}